{
  "slug": "modern-javascript-features",
  "title": "Modern JavaScript Features: ES2020+ You Should Know",
  "date": "2025-01-20",
  "content": "# Modern JavaScript Features: ES2020+ You Should Know\n\nJavaScript has evolved significantly in recent years. Let's explore the most useful modern features that will make your code cleaner and more powerful.\n\n## 1. Optional Chaining (?.)\n\nSafely access nested properties without throwing errors:\n\n```javascript\n// Before ES2020\nconst userName = user && user.profile && user.profile.name;\n\n// With Optional Chaining\nconst userName = user?.profile?.name;\n\n// Works with function calls too\nconst result = api?.getData?.();\n\n// Array access\nconst firstItem = array?.[0];\n```\n\n## 2. Nullish Coalescing (??)\n\nDistinguish between `null`/`undefined` and falsy values:\n\n```javascript\n// Before\nconst count = value || 0; // 0, false, \"\" all become 0\n\n// With Nullish Coalescing\nconst count = value ?? 0; // Only null/undefined become 0\n\n// Practical example\nconst userInput = \"\";\nconst displayName = userInput ?? \"Anonymous\"; // Shows \"\" instead of \"Anonymous\"\n\n// Combined with optional chaining\nconst name = user?.profile?.name ?? \"Unknown\";\n```\n\n## 3. BigInt\n\nHandle integers larger than 2^53 - 1:\n\n```javascript\n// Regular numbers have limitations\nconst maxSafe = Number.MAX_SAFE_INTEGER; // 9007199254740991\n\n// BigInt for large numbers\nconst bigNumber = 9007199254740991n;\nconst biggerNumber = BigInt(\"123456789012345678901234567890\");\n\n// Operations\nconst result = bigNumber + 1n; // 9007199254740992n\n\n// Note: Can't mix with regular numbers\n// const mixed = bigNumber + 1; // TypeError\n```\n\n## 4. Promise.allSettled()\n\nWait for all promises to complete, regardless of success/failure:\n\n```javascript\nconst promises = [\n  fetch('/api/users'),\n  fetch('/api/posts'),\n  Promise.reject(new Error('Network error'))\n];\n\nPromise.allSettled(promises).then(results => {\n  results.forEach(result => {\n    if (result.status === 'fulfilled') {\n      console.log('Success:', result.value);\n    } else {\n      console.log('Error:', result.reason);\n    }\n  });\n});\n```\n\n## 5. Dynamic Imports\n\nLoad modules conditionally at runtime:\n\n```javascript\n// Static import (always loaded)\nimport { utils } from './utils.js';\n\n// Dynamic import (loaded when needed)\nasync function loadModule() {\n  try {\n    const module = await import('./heavy-module.js');\n    module.doSomething();\n  } catch (error) {\n    console.error('Failed to load module:', error);\n  }\n}\n\n// With conditions\nif (user.hasPermission('admin')) {\n  const adminModule = await import('./admin-panel.js');\n  adminModule.init();\n}\n```\n\n## 6. Top-level await\n\nUse await outside of async functions (in modules):\n\n```javascript\n// config.js\nconst response = await fetch('/api/config');\nconst config = await response.json();\n\nexport default config;\n\n// main.js\nimport config from './config.js';\nconsole.log('Config loaded:', config);\n```\n\n## 7. String.prototype.matchAll()\n\nGet all matches with capture groups:\n\n```javascript\nconst text = 'Hello world, hello universe';\nconst regex = /hello/gi;\n\n// Before\nconst matches = text.match(regex); // ['Hello', 'hello']\n\n// With matchAll\nconst allMatches = [...text.matchAll(regex)];\n// [\n//   ['Hello', index: 0, input: 'Hello world, hello universe', groups: undefined],\n//   ['hello', index: 13, input: 'Hello world, hello universe', groups: undefined]\n// ]\n\n// With capture groups\nconst urlRegex = /(https?:\\/\\/[^\\s]+)/g;\nconst urls = [...text.matchAll(urlRegex)].map(match => match[1]);\n```\n\n## 8. globalThis\n\nConsistent way to access global object across environments:\n\n```javascript\n// Before (environment-specific)\nwindow.someGlobal = 'value'; // Browser\nglobal.someGlobal = 'value'; // Node.js\nself.someGlobal = 'value'; // Web Workers\n\n// With globalThis (works everywhere)\nglobalThis.someGlobal = 'value';\n\n// Check if globalThis is available\nif (typeof globalThis !== 'undefined') {\n  globalThis.myApp = {};\n}\n```\n\n## 9. Logical Assignment Operators\n\nCombine logical operators with assignment:\n\n```javascript\n// Logical AND assignment (&&=)\nlet user = null;\nuser &&= user.name; // Only assigns if user is truthy\n\n// Logical OR assignment (||=)\nlet config = {};\nconfig.apiUrl ||= 'https://api.example.com'; // Default value\n\n// Logical nullish assignment (??=)\nlet theme = null;\ntheme ??= 'light'; // Only assigns if theme is null/undefined\n\n// Practical example\nclass User {\n  constructor() {\n    this.preferences ??= {};\n    this.preferences.theme ??= 'dark';\n  }\n}\n```\n\n## 10. Numeric Separators\n\nMake large numbers more readable:\n\n```javascript\n// Before\nconst billion = 1000000000;\nconst pi = 3.14159265359;\n\n// With numeric separators\nconst billion = 1_000_000_000;\nconst pi = 3.141_592_653_59;\n\n// Works with different bases\nconst binary = 0b1010_0001_1000_0101;\nconst hex = 0xFF_FF_FF_FF;\n\n// In arrays and objects\nconst prices = [\n  1_000,\n  2_500,\n  10_000\n];\n```\n\n## 11. Array.prototype.flatMap()\n\nMap and flatten arrays in one operation:\n\n```javascript\nconst sentences = [\n  'Hello world',\n  'How are you?',\n  'JavaScript is awesome'\n];\n\n// Before\nconst words = sentences\n  .map(sentence => sentence.split(' '))\n  .flat();\n\n// With flatMap\nconst words = sentences.flatMap(sentence => sentence.split(' '));\n\n// Practical example\nconst users = [\n  { name: 'Alice', hobbies: ['reading', 'swimming'] },\n  { name: 'Bob', hobbies: ['gaming'] }\n];\n\nconst allHobbies = users.flatMap(user => user.hobbies);\n// ['reading', 'swimming', 'gaming']\n```\n\n## 12. Object.fromEntries()\n\nConvert arrays of key-value pairs to objects:\n\n```javascript\n// Convert Map to Object\nconst map = new Map([\n  ['name', 'John'],\n  ['age', 30],\n  ['city', 'New York']\n]);\n\nconst obj = Object.fromEntries(map);\n// { name: 'John', age: 30, city: 'New York' }\n\n// Convert URLSearchParams\nconst params = new URLSearchParams('name=John&age=30');\nconst queryObj = Object.fromEntries(params);\n\n// Transform arrays\nconst pairs = [['a', 1], ['b', 2], ['c', 3]];\nconst result = Object.fromEntries(pairs);\n// { a: 1, b: 2, c: 3 }\n```\n\n## Browser Support and Polyfills\n\n```javascript\n// Check for feature support\nif (!('optionalChaining' in Object)) {\n  // Load polyfill\n  import('@babel/polyfill');\n}\n\n// Or use feature detection\nif (typeof globalThis === 'undefined') {\n  // Fallback implementation\n  window.globalThis = window;\n}\n```\n\n## Best Practices\n\n- **Use TypeScript** for better type safety with modern features\n- **Check browser support** before using new features\n- **Use Babel** to transpile for older browsers\n- **Prefer modern features** over polyfills when possible\n- **Test thoroughly** across different environments\n\n> **Remember**: Modern JavaScript features make your code more readable, maintainable, and less error-prone.\n\n---\n\n*Embrace the future of JavaScript and write cleaner, more powerful code!*"
} 